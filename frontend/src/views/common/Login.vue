<script setup>
import { ref, onMounted, computed } from 'vue'
import { useI18n } from 'vue-i18n'
import { useRouter } from 'vue-router'

import AdminContact from '../common/AdminContact.vue'
import Turnstile from '../../components/Turnstile.vue'

import { useGlobalState } from '../../store'
import { api } from '../../api'
import { getRouterPathWithLang, hashPassword } from '../../utils'

const props = defineProps({
    bindUserAddress: {
        type: Function,
        default: async () => { await api.bindUserAddress(); },
        required: true
    },
    newAddressPath: {
        type: Function,
        default: async (address_name, domain, cf_token) => {
            return await api.fetch("/api/new_address", {
                method: "POST",
                body: JSON.stringify({
                    name: address_name,
                    domain: domain,
                    cf_token: cf_token,
                }),
            });
        },
        required: true
    },
})

const router = useRouter()

const snackbar = ref(false)
const snackbarText = ref('')
const snackbarColor = ref('info')

const showMessage = (text, color = 'info') => {
    snackbarText.value = text
    snackbarColor.value = color
    snackbar.value = true
}

const message = {
    error: (text) => showMessage(text, 'error'),
    info: (text) => showMessage(text, 'info'),
    success: (text) => showMessage(text, 'success'),
}

const notification = {
    info: () => {}
}

const {
    jwt, loading, openSettings,
    showAddressCredential, userSettings, addressPassword
} = useGlobalState()

const tabValue = ref('signin')
const credential = ref('')
const emailName = ref("")
const emailDomain = ref("")
const cfToken = ref("")
const loginMethod = ref('credential')
const loginAddress = ref('')
const loginPassword = ref('')

const initLoginMethod = () => {
    if (openSettings.value?.enableAddressPassword) {
        loginMethod.value = 'password';
    } else {
        loginMethod.value = 'credential';
    }
}

const login = async () => {
    if (loginMethod.value === 'password') {
        if (!loginAddress.value || !loginPassword.value) {
            message.error(t('emailPasswordRequired'));
            return;
        }
        try {
            const res = await api.fetch('/api/address_login', {
                method: 'POST',
                body: JSON.stringify({
                    email: loginAddress.value,
                    password: await hashPassword(loginPassword.value)
                })
            });
            jwt.value = res.jwt;
            await api.getSettings();
            try {
                await props.bindUserAddress();
            } catch (error) {
                message.error(`${t('bindUserAddressError')}: ${error.message}`);
            }
            await router.push(getRouterPathWithLang("/", locale.value));
        } catch (error) {
            message.error(error.message || "error");
        }
        return;
    }
    if (!credential.value) {
        message.error(t('credentialInput'));
        return;
    }
    try {
        jwt.value = credential.value;
        await api.getSettings();
        try {
            await props.bindUserAddress();
        } catch (error) {
            message.error(`${t('bindUserAddressError')}: ${error.message}`);
        }
        await router.push(getRouterPathWithLang("/", locale.value));
    } catch (error) {
        message.error(error.message || "error");
    }
}

const { locale, t } = useI18n({
    messages: {
        en: {
            login: 'Login',
            loginAndBind: 'Login and Bind',
            pleaseGetNewEmail: 'Please login or click "Get New Email" button to get a new email address',
            getNewEmail: 'Create New Email',
            getNewEmailTip1: 'Please input the email you want to use. only allow: ',
            getNewEmailTip2: 'Levaing it blank will generate a random email address.',
            getNewEmailTip3: 'You can choose a domain from the dropdown list.',
            credential: 'Email Address Credential',
            ok: 'OK',
            generateName: 'Generate Fake Name',
            help: 'Help',
            credentialInput: 'Please input the Mail Address Credential',
            bindUserInfo: 'Logged in user, login without binding email or create new email address will bind to current user',
            bindUserAddressError: 'Error when bind email address to user',
            autoGeneratedName: 'Auto-generated name',
            passwordLogin: 'Password Login',
            credentialLogin: 'Credential Login',
            email: 'Email',
            password: 'Password',
            emailPasswordRequired: 'Email and password are required',
        },
        zh: {
            login: '登录',
            loginAndBind: '登录并绑定',
            pleaseGetNewEmail: '请"登录"或点击 "注册新邮箱" 按钮来获取一个新的邮箱地址',
            getNewEmail: '创建新邮箱',
            getNewEmailTip1: '请输入你想要使用的邮箱地址, 只允许: ',
            getNewEmailTip2: '留空将会生成一个随机的邮箱地址。',
            getNewEmailTip3: '你可以从下拉列表中选择一个域名。',
            credential: '邮箱地址凭据',
            ok: '确定',
            generateName: '生成随机名字',
            help: '帮助',
            credentialInput: '请输入邮箱地址凭据',
            bindUserInfo: '已登录用户, 登录未绑定邮箱或创建新邮箱地址将绑定到当前用户',
            bindUserAddressError: '绑定邮箱地址到用户时错误',
            autoGeneratedName: '自动生成名称',
            passwordLogin: '密码登录',
            credentialLogin: '凭据登录',
            email: '邮箱',
            password: '密码',
            emailPasswordRequired: '邮箱和密码不能为空',
        }
    }
});

const loginAndBindTag = computed(() => {
    if (userSettings.value.user_email) {
        return t('loginAndBind')
    }
    return t('login')
})

const addressRegex = computed(() => {
    try {
        if (openSettings.value.addressRegex) {
            return new RegExp(openSettings.value.addressRegex, 'g');
        }
    } catch (error) {
        console.error(error);
        message.error(`Invalid addressRegex: ${openSettings.value.addressRegex}`);
    }
    return /[^a-z0-9]/g;
});

const generateNameLoading = ref(false);
const generateName = async () => {
    try {
        generateNameLoading.value = true;
        const { faker } = await import('https://esm.sh/@faker-js/faker');
        emailName.value = faker.internet.email()
            .split('@')[0]
            .replace(/\s+/g, '.')
            .replace(/\.{2,}/g, '.')
            .replace(addressRegex.value, '')
            .toLowerCase();
        if (emailName.value.length > openSettings.value.maxAddressLen) {
            emailName.value = emailName.value.slice(0, openSettings.value.maxAddressLen);
        }
    } catch (error) {
        message.error(error.message || "error");
    } finally {
        generateNameLoading.value = false;
    }
};

const newEmail = async () => {
    try {
        const nameToSend = openSettings.value.disableCustomAddressName ? "" : emailName.value;
        const res = await props.newAddressPath(
            nameToSend,
            emailDomain.value,
            cfToken.value
        );
        jwt.value = res["jwt"];
        addressPassword.value = res["password"] || '';
        await api.getSettings();
        await router.push(getRouterPathWithLang("/", locale.value));
        showAddressCredential.value = true;
        try {
            await props.bindUserAddress();
        } catch (error) {
            message.error(`${t('bindUserAddressError')}: ${error.message}`);
        }
    } catch (error) {
        message.error(error.message || "error");
    }
};

const addressPrefix = computed(() => {
    if (userSettings.value?.user_role) {
        return userSettings.value.user_role.prefix || "";
    }
    return openSettings.value.prefix;
});

const domainsOptions = computed(() => {
    if (userSettings.value.user_role) {
        const allDomains = userSettings.value.user_role.domains;
        if (!allDomains) return openSettings.value.domains;
        return openSettings.value.domains.filter((domain) => {
            return allDomains.includes(domain.value);
        });
    }
    if (!openSettings.value.defaultDomains) {
        return openSettings.value.domains;
    }
    return openSettings.value.domains.filter((domain) => {
        return openSettings.value.defaultDomains.includes(domain.value);
    });
});

const showNewAddressTab = computed(() => {
    if (openSettings.value.disableAnonymousUserCreateEmail
        && !userSettings.value.user_email
    ) {
        return false;
    }
    return openSettings.value.enableUserCreateEmail;
});

onMounted(async () => {
    if (!openSettings.value.domains || openSettings.value.domains.length === 0) {
        await api.getOpenSettings(message, notification);
    }
    emailDomain.value = domainsOptions.value ? domainsOptions.value[0]?.value : "";
    initLoginMethod();
});
</script>

<template>
    <div>
        <v-alert v-if="userSettings.user_email" type="info" variant="tonal" closable class="mb-4">
            {{ t('bindUserInfo') }}
        </v-alert>

        <v-tabs v-if="openSettings.fetched" v-model="tabValue" grow>
            <v-tab value="signin">{{ loginAndBindTag }}</v-tab>
            <v-tab v-if="showNewAddressTab" value="register">{{ t('getNewEmail') }}</v-tab>
            <v-tab value="help">{{ t('help') }}</v-tab>
        </v-tabs>

        <v-window v-model="tabValue" class="mt-4">
            <v-window-item value="signin">
                <v-form>
                    <div v-if="loginMethod === 'password'">
                        <v-text-field v-model="loginAddress" :label="t('email')" variant="outlined" 
                            density="compact" class="mb-2"></v-text-field>
                        <v-text-field v-model="loginPassword" :label="t('password')" type="password"
                            variant="outlined" density="compact" 
                            :append-inner-icon="'mdi-eye'" class="mb-2"></v-text-field>
                    </div>
                    <div v-else>
                        <v-textarea v-model="credential" :label="t('credential')" variant="outlined"
                            rows="3" class="mb-2"></v-textarea>
                    </div>

                    <div class="text-center mb-2">
                        <v-btn v-if="openSettings?.enableAddressPassword" variant="text" size="small" color="info"
                            @click="loginMethod === 'password' ? loginMethod = 'credential' : loginMethod = 'password'">
                            {{ loginMethod === 'password' ? t('credentialLogin') : t('passwordLogin') }}
                        </v-btn>
                    </div>

                    <v-btn @click="login" :loading="loading" color="primary" variant="outlined" block class="mb-2">
                        <v-icon start>mdi-email</v-icon>
                        {{ loginAndBindTag }}
                    </v-btn>
                    <v-btn v-if="showNewAddressTab" @click="tabValue = 'register'" variant="outlined" block>
                        <v-icon start>mdi-plus</v-icon>
                        {{ t('getNewEmail') }}
                    </v-btn>
                </v-form>
            </v-window-item>

            <v-window-item v-if="showNewAddressTab" value="register">
                <v-overlay :model-value="generateNameLoading" contained class="align-center justify-center">
                    <v-progress-circular indeterminate></v-progress-circular>
                </v-overlay>
                <v-form>
                    <p v-if="!openSettings.disableCustomAddressName" class="mb-2">
                        {{ t("getNewEmailTip1") + addressRegex.source }}
                    </p>
                    <p v-if="!openSettings.disableCustomAddressName" class="mb-2">{{ t("getNewEmailTip2") }}</p>
                    <p class="mb-4">{{ t("getNewEmailTip3") }}</p>

                    <v-btn v-if="!openSettings.disableCustomAddressName" @click="generateName" class="mb-4">
                        {{ t('generateName') }}
                    </v-btn>

                    <v-row dense>
                        <v-col v-if="addressPrefix" cols="auto">
                            <v-chip>{{ addressPrefix }}</v-chip>
                        </v-col>
                        <v-col>
                            <v-text-field v-if="!openSettings.disableCustomAddressName" v-model="emailName"
                                variant="outlined" density="compact" counter
                                :maxlength="openSettings.maxAddressLen"></v-text-field>
                            <v-text-field v-else :model-value="t('autoGeneratedName')" disabled
                                variant="outlined" density="compact"></v-text-field>
                        </v-col>
                        <v-col cols="auto">
                            <v-chip>@</v-chip>
                        </v-col>
                        <v-col>
                            <v-select v-model="emailDomain" :items="domainsOptions" item-title="label"
                                item-value="value" variant="outlined" density="compact"></v-select>
                        </v-col>
                    </v-row>

                    <Turnstile v-model:value="cfToken" />

                    <v-btn color="primary" variant="outlined" block @click="newEmail" :loading="loading" class="mt-4">
                        <v-icon start>mdi-plus</v-icon>
                        {{ t('getNewEmail') }}
                    </v-btn>
                </v-form>
            </v-window-item>

            <v-window-item value="help">
                <v-alert type="info" variant="tonal" class="mb-4">
                    {{ t('pleaseGetNewEmail') }}
                </v-alert>
                <AdminContact />
            </v-window-item>
        </v-window>

        <v-snackbar v-model="snackbar" :color="snackbarColor" timeout="3000">
            {{ snackbarText }}
        </v-snackbar>
    </div>
</template>
